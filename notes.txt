Str - count, find, replace, len, isupper, islower

list - negative index, append, insert, extend, remove, pop, reverse, sort, sorted, sort(reverse=True),
        index, 

number list - min, max, sum

functions - An executed function is equal to the return value.  
            When we simply call a function that returns some value,we won't be able to see output.
            To see the output of a function that returns some value, we have to print the function
            calling statement, such as "print(test())".
            When an executed function returns some value,we can use different built-in methods to
            work with the returned data. For example, "print(max(test()))".
          - Passing default values to function arguments and overriding the default arg values
          - Positional and Keyword arguments (*arg,**kwarg)
            *args - Positional argumnts are the args without any default values. so when we invoke 
            the function, we must pass values. *arg allows us to pass any number of args/values to
            our function.
            **kwargs - Keyword arguments are the ones with default values. We can pass any many
            keyword arguments we want to our function.
            It's not mandatory to have *arg,**kwarg for arg names. It can be anything like,
            *student,**marks. The prfix * or ** is what matters.

            Example: 1
            def test(*args,**kwargs):
                print("Here the positional arguments are: ",args)
                print("Here the keyword arguments are: ", kwargs)
            test('Anand',28,'Chennai')

            O/P:
            Here the positional arguments are:  Anand 28 Chennai
            Here the keyword arguments are:

            Example: 2
            
            def test(*args,**kwargs):
                print("Here the positional arguments are: ",args)
                print("Here the keyword arguments are: ", kwargs)
            test('Anand',28,'Chennai',Maths=100, Tamil=100)

            O/P:
            Here the positional arguments are:  ('Anand', 28, 'Chennai')
            Here the keyword arguments are:  {'Maths': 100, 'Tamil': 100}


          - We can see the positional arguments returned a tuple as output and keyword arguments 
            returned a dictionary as output.

          - One important thing to remeber is that we must complete passing the positional args first
            and then keyword args. Can't provide a mixture of arg values such as,
            test('Anand',28,'Chennai',Maths=100, Tamil=100,'TN')
            It will throw an error: "positional argument follows keyword argument"

          - When we pass variables as arguments in fucntion invoking for positional and keyword args, 
            we must be careful.
            Wrong way:
            def test(*stu,**details):
                print("Here the positional arguments are: ",stu)
                print("Here the keyword arguments are: ", details)
                student=['Anand',28,'Chennai']
                det= {'Maths': 100, 'Tamil': 100}
            test(student,det)

            O/P:
            Here the positional arguments are:  (['Anand', 28, 'Chennai'], {'Maths': 100, 'Tamil': 100})
            Here the keyword arguments are:  {}

            We can see that the function took both variables as positional arguments.

            Right way:
            test(*student,**det)

            O/P:
            Here the positional arguments are:  ('Anand', 28, 'Chennai')
            Here the keyword arguments are:  {'Maths': 100, 'Tamil': 100}

            
Importing modules - When we import an module, we can import the entire module by specifying
                    "import module_name" , which will allow us to access every functions, variables
                    and statements from that module.
                    If we want to explicitly access only functions or variables within that module,
                    we can specify that as "from module_name import function" or
                    "from module_name import function as f,variable as v" with nicknames or
                    we can use "from module_name import *" which is similar to "import module_name"
                  - Whenever we import a module, python finds the module in the background by
                    going through a list of directories/paths, starting with our cwd. To see what
                    paths it checks, we can import the sys module and use sys.path to list out the
                    paths python searches for the module.
                  - If the module is not found in any of the default directories, it will throw a 
                    "ModuleNotFound" error. In this case we can explicitly define the path of our
                    module using the sys module and "sys.path.append('C:/Users/Admin/Desktop')" before we import
                    the module.
                  - If we have a different dir/path that has our modules, we can add it to the
                    python's default paths by adding an environment variable in settings.
                    Ex - PYTHONPATH - C:/Users/Admin/Desktop/SearchModule
                    Now,everytime we import a module, python will look for that module in the newly
                    added default path, along with other paths.


Random module - random.random() - It will output a random floating number between 0 to 1.
                random.randint(a,b) - It will output a random integer number between a and b, 
                                      including a and b.
                random.choice(a) - It takes a list as an argument and output random values from
                                   that list.

Math module - math.radians(x) - Converts angle x from degrees to radians
              math.sin(), math.cos(), math.tan()

Datetime module - datetime.datetime(2018,8,2) - 2018-08-02 00:00:00
                  datetime.datetime.today() - 2018-08-11 16:53:46.830487
                  datetime.datetime.now() - 2018-08-11 16:54:58.071950

Calendar module - calendar.isleap(2018) - False
                  calendar.isleap(2020) - True

OS module - os.getcwd() - To return the current working directory
          - os.path.isdir('git') - To check whether there is a directory with the name git
          - os.path.isfile('test.py') - To check if there is a file with the name test.py
          - os.__file__   - This will return the file location/path of OS module - os.py
          - random.__file__  - Same as above, but it will return the path of random module
          - os.chdir('C:/Users/Admin/Desktop') - To navigate/change the cwd
          - os.listdir() - It will list the files and folders in the cwd. 
            We can specify a path too, such as os.listdir('C:/Codes')
          - os.mkdir('Test') - To create a directory. With mkdir, we can create only one directory
          - os.makedirs('Testfolder/Test1/Test2/Test3') - With makedirs, we can create nested dirs
          - os.rmdir('Test') - To remove a single directory that does not have any sub directories
            If it has sub dirs, then first we should delete the sub dirs "os.rmdir('Test/Test1').
            This will delete the Test1 dir. Then we have to delete Test dir.
          - os.removedirs('Testfolder/Test1/Test2/Test3') - Removedirs will delete all parent and
            child directories at one go.
          - os.rename('file/dir','file/dir'), - To rename files and directories
          - os.stat('style.css') - To know details about a file or dir. It will output many stats.
            We can also explicitly mention the stat to see the specific output.
            "os.stat('style.css').st_size" - To see the file size
            "os.stat('Files').st_mtime" - To see last modified time. O/P - 1533716640.870916
            This time output is not human readable. So, we can use the datetime module to Converts
            it to a human readable date and time.
            
            mtime=os.stat('style.css).st_mtime
            print(datetime.fromtimestamp(mtime))

            O/P: 2018-08-08 13:54:00.870916
          - os.walk() - This is a generator which will display the dir path, dir names within 
            that path and file names within that dir. It will walk through all paths/dirs/files
            until the entire tree is completed. 

            for mypath,mydir,myfiles in os.walk(os.getcwd()):
              print("Current path: ",mypath)
              print("Current Dir: ",mydir)
              print("Files: ",myfiles)
              print()
          
          - os.environ - To list all the environment variables in our system

          - os.environ.get('USERPROFILE')- To view the value of a particular environment variable
            O/P: C:\Users\Admin

            os.environ.get('PYTHONPATH')
            O/P: C:\Users\Admin\Desktop\SearchModule
          
          - os.path.join(a,b,c,...) - When we want to create a file in our desired dir, it's 
            recommended to use the os.path.join() method. For example, if we do the following way
            create a file in the path, the output will be wrong.
            
            WRONG WAY:
            file_path=os.environ.get('PYTHONPATH')+'test.txt'
            O/P: C:\Users\Admin\Desktop\SearchModuletest.txt

            See, there is no \ between the 'SearchModule' folder and test.txt file.

            RIGHT WAY:
            file_path=os.path.join(os.environ.get('PYTHONPATH'),'test.txt')
            print(file_path)

            O/P: C:\Users\Admin\Desktop\SearchModule\test.txt

            Then, we can also use that file_path to create the file in the dir we joined it with.

            "with open(file_path,"w") as f:"
          
          - os.path.basename('C:/Users/Admin/Desktop/SearchModule/test.txt') - basename will
            the last item in the path AFTER /
            O/P: test.txt

            os.path.basename(C:/Users/Admin/Desktop/SearchModule)
            O/P: SearchModule

            os.path.basename(C:/Users/Admin/Desktop/)
            O/P:  (none) - because there is a / in the path but nothing after that

          - os.path.dirname('C:/Users/Admin/Desktop/SearchModule/test.txt') - dirname will return
            the dir/path BEFORE /
            O/P: C:/Users/Admin/Desktop/SearchModule

            os.path.dirname('C:/Users/Admin/Desktop/SearchModule/')
            O/P: C:/Users/Admin/Desktop/SearchModule

            os.path.dirname('C:/Users/Admin/Desktop/SearchModule')
            O/P: C:/Users/Admin/Desktop

          - os.path.split('C:/Users/Admin/Desktop/SearchModule/test.txt') - This will split the 
            content before and after the last / and output the result as a tuple.
            O/P: ('C:/Users/Admin/Desktop/SearchModule', 'test.txt')

            os.path.split('C:/Users/Admin/Desktop/SearchModule/')
            O/P: ('C:/Users/Admin/Desktop/SearchModule', '')

            os.path.split('C:/Users/Admin/Desktop/SearchModule')
            O/P: ('C:/Users/Admin/Desktop', 'SearchModule')

          - os.path.exists('C:/Users/Admin/Desktop/SearchModule') - checks if the path exist or not
            Returns True or False accordingly.

          - os.path.isdir(path) - It will check whether the given input is a dir or not

          - os.path.isfile(path) - It will check whether the given input is a file or not

          - os.path.splitext('Desktop/SearchModule/test.txt') - Split EXT - Split extention.
            It will split the dir with filename as one item and extension as another item and 
            output it as a tuple.
            O/P: ('Desktop/SearchModule/test', '.txt')

          - dir(os.path) - To see all modules that are available for os.path


string.zfill(x) - This method is used to add padding zeros to the left. x refers to the number of 
                  digits we want.

                  test="8"
                  print(test.zfill(2))
                  print(test.zfill(5))

                  O/P:
                  08
                  00008

                  test="test"
                  print(test.zfill(2))
                  print(test.zfill(5))
                  print(test.zfill(10))

                  O/P:
                  test
                  0test
                  000000test


CSV Module - csv.reader(csvfile) - This reader method has a dialect in the background which is expecting 
            comma seperated values in the data.
            We have to iterate over the reader variable to see the output, as shown below.

            import csv
            with open("sample.csv") as csvfile:
                csv_reader=csv.reader(csvfile)
                for i in csv_reader:
                    print(i)

            O/P:
            ['first_name', 'last_name', 'email']
            ['Anand', 'Kumar', 'anandkumarg890@gmail.com']
            ['Shiva', 'Kishore', 'shiva@gmail.com']

            We can see the ouput is in the list format with the comma seperated values.

            To see only the emails, we can use indexing.

            import csv
            with open("sample.csv") as csvfile:
                csv_reader=csv.reader(csvfile)
                for i in csv_reader:
                    print(i[2])

            O/P:
            email
            anandkumarg890@gmail.com
            shiva@gmail.com

      next - is a keyword/generator which can be used to skip over values and iterables.

             import csv
             with open("sample.csv") as csvfile:
                  csv_reader=csv.reader(csvfile)
                  next(csv_reader)
                  for i in csv_reader:
                      print(i)
            
              O/P:
              ['Anand', 'Kumar', 'anandkumarg890@gmail.com']
              ['Shiva', 'Kishore', 'shiva@gmail.com']
            
            We can see it skipped the inital header list, since we used the next function.
      
      delimiters - When we read or write from a csv file, we can specify how we want our data to be parsed
                   using delimiters.

                   with open("sample1.csv") as rfile:
                      csv_reader=csv.reader(rfile,delimiter='-')
                      for l in csv_reader:
                          print(l)
                   
                   Same way, delimeters can be used when we write/append a csv file too. The following Codes
                   shows how we can do that, along with how we can copy data from one csv file to another.

                   with open("sample.csv") as rfile:
                      csv_reader=csv.reader(rfile)
                      with open("sample1.csv","w",newline='') as wfile:
                          csv_writer=csv.writer(wfile,delimiter='-')
                          for lines in csv_reader:
                              csv_writer.writerow(lines)

      csv.DictReader(csv_file) - This method will take a csv file as an argument and return the output
                                in dictionary format. It won't output the header values, as they are
                                considered rto be the keys for the dictionary values.

                                import csv
                                with open("sample.csv") as rfile:
                                    csv_reader=csv.DictReader(rfile)
                                    for l in csv_reader:
                                        print(l)
                                
                                O/P:
                                OrderedDict([('first_name', 'Anand'), ('last_name', 'Kumar'), ('email', 'anandkumarg890@gmail.com')])
                                OrderedDict([('first_name', 'Shiva'), ('last_name', 'Kishore'), ('email', 'shiva@gmail.com')])

                                To retrieve data with key names,

                                import csv
                                with open("sample.csv") as rfile:
                                    csv_reader=csv.DictReader(rfile)
                                    for l in csv_reader:
                                        print(l['email'])

                                O/P:
                                anandkumarg890@gmail.com
                                shiva@gmail.com


                                This is better than regular csv.reader() because we don't always know
                                the indexing of our values. With csv.DictReader() or writer, we can use
                                keys to get values.

                                To copy one csv file to another using dictionary method in csv,

                                import csv
                                with open("sample.csv") as rf:
                                    csv_reader=csv.DictReader(rf)
                                    with open("sample1.csv","w") as wf:
                                        csv_header=['fname', 'lname','email']
                                        csv_writer=csv.DictWriter(wf,fieldnames=csv_header,delimiter='-')
                                        csv_writer.writeheader()
                                        for lines in csv_reader:
                                            csv_writer.writerow(lines)

When we copy data from one csv file to another csv file, we can decide what fields we want to copy.
We can remove/eliminate the fields we don't want to write to our new csv file.

import csv
with open("sample.csv") as rf:
    csv_reader=csv.DictReader(rf)
    with open("sample1.csv","w") as wf:
        csv_header=['fname', 'lname']
        csv_writer=csv.DictWriter(wf,fieldnames=csv_header,delimiter='\t')
        csv_writer.writeheader()
        for lines in csv_reader:
            del lines['email']
            csv_writer.writerow(lines)

The above code will write only first and last names to the new csv file. It won't copy email as we
deleted email during each iteration.



DateTime Module - Naive dates and times don't have enough information to determine timezones or
day light saving times. It can be used for high-level things.

datetime.date(yyyy,m,d) - In this method, we should always give m,d in single digits without 
preceding 0.

import datetime
d=datetime.date(2018,8,19)
print(d)

O/P:
2018-08-19

We can see that it added a 0 in left padding for month.

d=datetime.date(2018,08,19)
d=datetime.date(2018,8,09)

These 2 will return an error.

datetime.date.today() - This method will retun current date.

We can also extract lot more details from the date as follows.

import datetime
d=datetime.date.today()
print(d)
print(d.year)
print(d.month)
print(d.day)
print(d.weekday())  # Monday 0 Sunday 6
print(d.isoweekday())   # Monday 1 Sunday 7

O/P:
2018-08-19
2018
8
19
6
7

datetime.timedelta() - It is simply the difference between two dates or times.

import datetime
tday=datetime.date.today()
tdelta=datetime.timedelta(days=17)
print(tday)
print(tday+tdelta)

O/P:
2018-08-19
2018-09-05

If ww add or subtract date from timedelta, we get another date. If we add or subtract two days, we get
timedelta.

import datetime
tday=datetime.date.today()
bday=datetime.date(2019,8,2)
tdelta=bday-tday
print(tdelta)

O/P:
348 days, 0:00:00

We can also extract data from timedelta as follows.

import datetime
tday=datetime.date.today()
bday=datetime.date(2019,8,2)
tdelta=bday-tday
print("Number of days till my next birth day is ",tdelta.days)

O/P:
Number of days till my next birth day is  348

import datetime
tday=datetime.date.today()
bday=datetime.date(2019,8,2)
tdelta=bday-tday
print("Number of seconds till my next birth day is ",tdelta.total_seconds())

O/P:
Number of days till my next birth day is  30067200.0

datetime.time() - This module allows us to have access only to hours,minutes,seconds and microseconds.
This module will not have access to year, month and day. For year, month and day, we have to use
datetime.date() module.

import datetime
d=datetime.time(12,57,23,236484)
print(d)

O/P:
12:57:23.236484

datetime.datetime() - This module has access to both datetime.date() and datetime.time(), which 
means, we can access year, month, day, hour, minutes seconds and microseconds all together with this module.

import datetime
d=datetime.datetime(2018,8,19,11,51,55,343543)
print(d)

O/P:
2018-08-19 11:51:55.343543

With the datetime.datetime() module, we can also extract the date and time seperately.

import datetime
dt=datetime.datetime(2018,8,19,11,51,55,343543)
print(dt.date())
print(dt.time())
print(dt.year)

O/P:
2018-08-19
11:51:55.343543
2018

We can also use timedelta with datetime.datetime() module.

import datetime
dt=datetime.datetime(2018,8,19,11,51,55,343543)
tdelta=datetime.timedelta(days=10)
print(dt+tdelta)

O/P:
2018-08-29 11:51:55.343543

Unlike datetim.date() module, with datetime.datetim() module, we can use timedelta to add/subtract
hours too.

import datetime
dt=datetime.datetime(2018,8,19,11,51,55,343543)
tdelta=datetime.timedelta(hours=10)
tdelta1=datetime.timedelta(minutes=10)
print(dt+tdelta)
print(dt+tdelta1)

O/P:
2018-08-19 21:51:55.343543
2018-08-19 12:01:55.343543

In the following code, we can see three differnt methods of datetime.datetime() module.

import datetime
print(datetime.datetime.today())    # Returns current local date time with timezone of none
print(datetime.datetime.now())      # We can pass in timezone attributes to now() method. Leaving timezone empty will yield same output as today()
print(datetime.datetime.utcnow())   # Provides current UTC time, but timezone is not set

O/P:
2018-08-19 12:05:45.473871
2018-08-19 12:05:45.473870
2018-08-19 06:35:45.473870


pytz package - We can install and use pytz package to work with timezones. It's officially recommended
by Python too.

It's recommended to use UTC timezones with pytz module.

import datetime as dt
import pytz
mydt=dt.datetime(2018,8,19,12,39,23, tzinfo=pytz.UTC)
print(mydt)

O/P:
2018-08-19 12:39:23+00:00

In the output, we can see +00:00 which is the UTC timezone offset.

As mentioned before, we can use timezones only with datetime.datetime.now() and datetime.datetime.utcnow().
We cannot use timezones with datetime.datetime.today() method. The following code is an example for that.

import datetime as dt
import pytz
mydt=dt.datetime.now(tz=pytz.UTC) # Better option
mydt1=dt.datetime.utcnow().replace(tzinfo=pytz.UTC) # Extra coding. So suggested to use the above code line.
print(mydt)
print(mydt1)

O/P:
2018-08-19 07:13:20.229129+00:00
2018-08-19 07:13:20.229141+00:00

To convert UTC timezone to another timezone, we can use the astimezone(pytz.timezone('zone')) method.

import datetime as dt
import pytz
mydt=dt.datetime.now(tz=pytz.UTC)
ustime=mydt.astimezone(pytz.timezone('US/Central'))
mytime=mydt.astimezone(pytz.timezone('Asia/Kolkata'))
print(mydt)
print(ustime)
print(mytime)

O/P:
2018-08-19 07:20:41.822282+00:00
2018-08-19 02:20:41.822282-05:00
2018-08-19 12:50:41.822282+05:30

To see all timezones offered by pytz module, we can run the code below.

for tz in pytz.all_timezones:
  print(tz)

ISO timezone format - We can also convert our date and time to isoformat, which is international standard.

import datetime as dt
import pytz
mydt=dt.datetime.now(tz=pytz.UTC)
est=mydt.astimezone(pytz.timezone('US/Eastern'))
print(mydt)
print(est)
print(est.isoformat())

O/P:
2018-08-19 07:37:36.546383+00:00
2018-08-19 03:37:36.546383-04:00
2018-08-19T03:37:36.546383-04:00

strftime(format) - String Format Time. This method can be used to format our date and time in the way we want. 
This method also converts the date into a string.

import datetime as dt
import pytz
mydt=dt.datetime.now(tz=pytz.UTC)
est=mydt.astimezone(pytz.timezone('US/Eastern'))
print(est)
print(est.strftime('%b %d, %Y'))
print(est.strftime('%B %d, %Y'))
print(est.strftime('%B %d, %y'))

O/P:
2018-08-19 03:42:51.342224-04:00
Aug 19, 2018
August 19, 2018
August 19, 18


strptime() - String Parse Time. To convert string to date/time format. Opposite of strftime() method.

import datetime as dt
import pytz
mydt=dt.datetime.now(tz=pytz.UTC)
est=mydt.astimezone(pytz.timezone('US/Eastern'))
date_string='August 19, 2018'
new_date=dt.datetime.strptime(date_string,'%B %d, %Y')
print(new_date)

O/P:
2018-08-19 00:00:00


The following code provides a detailed explanation of strftime() and strptime() methods.

import datetime 
import pytz
mydt=datetime.datetime.now(tz=pytz.UTC) # To convert it into UTC timezone
print(mydt)
est_time=mydt.astimezone(pytz.timezone('US/Eastern'))
print(est_time)
date_to_string=est_time.strftime('%B %d, %Y') # String Format Time. Converts date/time into string. The output is a string now.
print(date_to_string)
string_to_date=datetime.datetime.strptime(date_to_string,'%B %d, %Y') # String Parse Time.This method takes two args. One arg is the string that contains date as string and another arg is the format. This method converts the string to date/time format.
print(string_to_date)
print(string_to_date.date()) # To extract only the date from the output

O/P:
2018-08-19 08:00:43.344953+00:00
2018-08-19 04:00:43.344953-04:00
August 19, 2018
2018-08-19 00:00:00
2018-08-19


LEGB - The arguments we pass to a function is also local variables and it's scope is within that
function. The following code will work fine.

def test(z):
    x='local x'
    print(z)
    print(x)
test('Another local variable z')

O/P:
Another local variable z
local x

But, if we try to refer the local variables z and x outside of the function, it will throw an error.

def test(z):
    x='local x'
    print(z)
    print(x)
test('Another local variable z')
print(z)
print(x)

O/P:
Another local variable z
local x
NameError: name 'z' is not defined


Enclosed - Let's say we have nested functions or nested blocka of codee. Within that nested code,
we may use the same variable name multiple times. But each time when a variable is refered, Python
will follow the LEGB order to find the value of the variable,

def outer():
    x='outer x'     # local variable to outer function
    def inner():
        x='inner x' # local variable to inner function
        print(x)
    inner()
    print(x)
outer()

O/P:
inner x
outer x

We can see that the above code printed out the local variables of both inner and outer function respectively.

def outer():
    x='outer x'     # local variable to outer function
    def inner():
        
        print(x)    
    inner()
    print(x)
outer()

O/P:
outer x
outer x

In the above code, inner function does not have a local variable x. So by LEGB order, it printed out
the enclosed variable x value.

def outer():    
    def inner():
        x='inner x' # local variable to inner function
        print(x)
    inner()
    print(x)
outer()

O/P:
inner x
NameError: name 'x' is not defined

The above code returned an error, because within the inner function, it had a local variable x. 
So it printed that out. Within outer function, we don't have any local, enclosed, global or built-in
variable with the variable name x.

Note: Enclosed rule will search for variables from within to outer order of nested code, not vice versa.


Just like how we can use the 'global' keyword to overwrite the value of global variable within
nested codes, we can use the keyword 'nonlocal' to overwrite the value of enclosed variable.

def outer():
    x='outer x'     # local variable to outer function
    def inner():
        nonlocal x  # We are refering the enclosed variable here
        x='inner x' # It overwrites the value of enclosed variable x
        print(x)
    inner()
    print(x)
outer()

O/P;
inner x
inner x

In the above code, we can see that the enclosed variable x value was overwritten by using the 
keyword 'nonlocal'.

The code below is an overall example of LEGB rule.

x='global x'
def outer():
    x='outer x'     # local variable to outer function
    def inner():
        x='inner x' # local variable to inner function
        print(x)
    inner()
    print(x)
outer()
print(x)

O/P:
inner x
outer x
global x


Sorting Lists, Tuples, Dictionaries and Objects:
Sort vs Sorted() method:
Sort method will sort the actual list and replace/overwrite the original list with the sorted values.
Sorted method can be assigned to a variable. This will not affect the original list.

Another difference is, sort method will work only with lists. But sorted method will work with lists, 
tuples and dictionaries.

num=[8,0,23,-1,100,2,-2,8,20]
print(num)      # Before sorting
num.sort()
print(num)      # After sorting

O/P:
[8, 0, 23, -1, 100, 2, -2, 8, 20]
[-2, -1, 0, 2, 8, 8, 20, 23, 100]


num=[8,0,23,-1,100,2,-2,8,20]
print(num)      # Before sorting
new_num=sorted(num)
print(num)      # After sorting
print(new_num)  # Result

O/P:
[8, 0, 23, -1, 100, 2, -2, 8, 20]
[8, 0, 23, -1, 100, 2, -2, 8, 20]
[-2, -1, 0, 2, 8, 8, 20, 23, 100]


To sort the list in descending order, we can use the keyword 'reverse=True' in both sort and sorted
methods.

num=[8,0,23,-1,100,2,-2,8,20]
num.sort(reverse=True)
print(num)

O/P:
[100, 23, 20, 8, 8, 2, 0, -1, -2]


num=[8,0,23,-1,100,2,-2,8,20]
new_num=sorted(num,reverse=True)
print(new_num)

O/P:
[100, 23, 20, 8, 8, 2, 0, -1, -2]


As mentioned before, sort method will work only with lists. But sorted method will work with lists, 
tuples and dictionaries. However, the output of a sorted method is always a list.

num=[8,0,23,-1,100,2,-2,8,20]
tup=(34,5,12,0,-5,100,1)
dic={'name':'anand','age':28,'city':'chennai'}
sorted_list=sorted(num)
sorted_tuple=sorted(tup)
sorted_dict=sorted(dic)
print(sorted_list)
print(sorted_tuple)
print(sorted_dict)

O/P:
[-2, -1, 0, 2, 8, 8, 20, 23, 100]
[-5, 0, 1, 5, 12, 34, 100]
['age', 'city', 'name']


Other than ascending and descending order, we can also use the keyword 'key' as an argument to the
sorted function and sort the items based on different criteria. For example, the following code
first converts each list item as an absolute (abs) value and then sort it.

num=[8,0,23,-1,100,2,-2,8,20]
new_num=sorted(num)
new_num_abs=sorted(num,key=abs)
print(new_num)
print(new_num_abs)

O/P:
[-2, -1, 0, 2, 8, 8, 20, 23, 100]
[0, -1, 2, -2, 8, 8, 20, 23, 100]


The value we assign for the 'key' in sorted method can be a built-in method or our own custom function.

num=[8,0,23,-1,100,2,-2,8,20]

def test(num):      # This function does not do anything. 
    return num
new_num=sorted(num,key=test)
print(new_num)

O/P:
[-2, -1, 0, 2, 8, 8, 20, 23, 100]

In the above code, we have used our custom function 'test' as the value for 'key' in sorted method, 
instead of built-in function. The test function does not do anything. This is just to show an example
that we can use custom functions as value for 'key' argument in sorted method.

We can also pass the 'reverse' argument, along with 'key' argument in the sorted function.

num=[8,0,23,-1,100,2,-2,8,20]
def test(num):      # This function does not do anything. 
    return num
new_num=sorted(num,key=test, reverse=True)
print(new_num)

O/P:
[100, 23, 20, 8, 8, 2, 0, -1, -2]


Error Handling : Try/Except

The 'Try' block will be executed first and if there are any errors in the 'Try' block, we can catch 
that error and use the 'Except' block to execute/print some other code.
This way, we can print out some clear error messages instead of the long error messages printed out
by default in Python.

try:
    with open("testt") as f:
        pass
except:
    print("No such file")

O/P:
No such file

In the above code, we have a try and except block. In this code, the except block is very generic,
which means no matter what type of error occurs in the try block, it will execute the same except
block for all type of errors.
For example, the following code may have the right file name, but some other error. Python will
still execute the 'generic' except block.

try:
    with open("test.py") as f:
        pass
    jhkkh
except:
    print("No such file")

O/P:
No such file

In the above code, we have some random characters as part of the try block. But the output is the same.


We can target specific errors by specifying the error type as part of the exception code.

try:
    with open("testt.py") as f:
        pass    
except FileNotFoundError:
    print("No such file")

O/P:
No such file

The above code has a wrong file name in the try block and since we have specified the particular
error type in the Except block, it will execute the Except code only for that error type.

For example, the below code has incorrect variable names and since we have no specific except block
for that error, it will return the default Python error.

try:
    with open("test.py") as f:
        pass
    var1=bad_var
except FileNotFoundError:
    print("No such file")

O/P:
NameError: name 'bad_var' is not defined

But if we have a common except block, then the errors other than the specified errors will execute
this common except block.

try:
    with open("test.py") as f:
        pass
    var1=bad_var
except FileNotFoundError:
    print("No such file")
except:
    print("Some other error")

O/P:
Some other error

And if we have multiple errors in Try block and each error has its own Except errorcode block, then
it will execute only the exception block of the first error it finds in the Try block.
The following code has both wrong file name and incorrect variable name. But it will execute the 
file error exception as it comes first in the code execution.

try:
    with open("test1.py") as f:
        pass
    var1=bad_var
except FileNotFoundError:
    print("No such file")
except NameError:
    print("Some other error")

O/P:
No such file

Note: Always code the common exception block at the bottom of specific exceptions. Otherwise, Python
will throw an error.

try:
    var1=var2
    with open("test.py") as f:
        pass
except:
    print("Common exception block")    
except FileNotFoundError:
    print("No such file")
except NameError:
    print("Some other error")

O/P:
SyntaxError: default 'except:' must be last

However, instead of simply typing 'except' for generic exception, if we type 'except Exception' in
the code, Python won't throw an error. The problem is, it will execute the generic 
'except Exception' block as it is coded first before the specific exceptions.

try:
    var1=var2
    with open("test.py") as f:
        pass
except Exception:
    print("Common exception block")    
except FileNotFoundError:
    print("No such file")
except NameError:
    print("Some other error")

O/P:
Common exception block


Instead of printing different messages for different errros, we can also print a clear error
message by assigning a variable for each exception and then printing the variable, like shown in
the code below.

try:
    with open("test1.py") as f:
        pass
except FileNotFoundError as e:
    print(e)

O/P:
[Errno 2] No such file or directory: 'test1.py'


try:
    var1=var2
    with open("test.py") as f:
        pass
except FileNotFoundError as e:
    print(e)
except NameError as e:
    print(e)

O/P:
name 'var2' is not defined



'Else' with Try/Except:

We can use 'Else' block to execute code, when there are no errors in the Try block.

The code below has an error in the file name, so it will execute the specified exception.

try:
    f=open("test.atxt")        
except FileNotFoundError as e:
    print(e)
else:
    print(f.read())
    f.close()

O/P:
[Errno 2] No such file or directory: 'test.atxt'

If we remove the error, then there will be no exception. Hence, it will execute the Else block.
In simple words, if there are errors, it will execute the exception. If there are no errors, it will
execute the Else block.

try:
    f=open("test.txt")        
except FileNotFoundError as e:
    print(e)
else:
    print(f.read())
    f.close()

O/P:
Hello There!


Finally block:

Unlike 'Else' block which will run only when there are no errors/exceptions, 'Finally' block will
run no matter what. Even if there are errors/exceptions or no errors/exception, it will always
execute the 'Finally' block following the Try or Exception or Else block.

try:
    f=open("tesst.txt")        
except FileNotFoundError as e:
    print(e)
else:
    print(f.read())
    f.close()
finally:
    print("Code execution completed")

O/P:
[Errno 2] No such file or directory: 'tesst.txt'
Code execution completed


try:
    f=open("test.txt")        
except FileNotFoundError as e:
    print(e)
else:
    print(f.read())
    f.close()
finally:
    print("Code execution completed")

O/P:
Hello There!
Code execution completed


Another good example is, we may want to place our file closing code in the 'Finally' block. So
even if the code was successful or not, it will close the file at the end of code execution.


try:
    f=open("test.txt")        
except FileNotFoundError as e:
    print(e)
else:
    print(f.read())
finally:
    f.close()
    print("File closed")

O/P:
Hello There!
File closed


Raising Exceptions:
We can also raise exceptions manaually, when required.

try:
    f=open("test.txt")
    if f.name=='test.txt':
        raise Exception         # Manually raising the exception
except FileNotFoundError as e:
    print(e)
except Exception:
    print("Please consider using a different file name")
else:
    print(f.read())
finally:
    f.close()
    print("File closed")

O/P:
Please consider using a different file name
File closed



Classes:
Classes allow us to logically group our data and modules, so we can reuse them and it is easy to 
build upon them if needed.
Data and functions within classses are called as attributes and methods.
Method - A function that is associated with the class.
Attribute - Data that is associated with aq class

We can also describe classes as blueprints.

Class instances - Class is basically a blueprint to create instances.


class Employee:
    pass
emp1=Employee()     # Class instance 1
emp2=Employee()     # Class instance 2
print(emp1)
print(emp2)

O/P:
<__main__.Employee object at 0x009BADD0>
<__main__.Employee object at 0x009BFD90>

In the above code, the output shows the memory location of class instances emp1 and emp2. This means
that each class instance is different and unique on its own and it has its own memory location.
In short, class instances (instance variables) contain data that are unique to each instances.


class Employee:
    pass
emp1=Employee()     # Class instance 1
emp2=Employee()     # Class instance 2

# We can assign different attributes/data to each class instances
emp1.name='Anand'
emp1.age=28
emp1.city='Chennai'

emp2.name='Kumar'
emp2.email='test@test.com'
print(emp1.name)
print(emp2.email)

O/P:
Anand
test@test.com

In the code above, we have created different attributes for each instances and we are able to
access them individually.

When we create a method within a class, it recieves the instance as the first variable. 
By convention, we can use the keyword 'self' to denote the instance.


In the code above, we have a lot of code which basically sets up values for class instance attributes.
As mentioned before, classes are blueprints to create instances. The following code will show how
simply we can create classes, class instances, pass arguments and use classes as blueprints.


class Employee:
    def __init__(self,fname,lname,age):
        self.fname=fname
        self.lname=lname
        self.age=age
        self.email=fname+'.'+lname+'@company.com'
emp1=Employee('Anand','Kumar',28)
emp2=Employee('Test','User',None)
print(emp1.email)
print(emp2.email)

O/P:
Anand.Kumar@company.com
Test.User@company.com

As mentioned earlier, methods within classes will take the class instance variable as the first
argument automatically by default. So, we don't have to pass the class variable as argument 1 
manually, when we create class instance variables.

During each class instance variable creation, the keyword 'self' within the class method will be
replaced by the class variable name such as emp1 and emp2 during execution.


Let's say we want to print out the fullname of each employee. This can be done as shown in the code below.

print('{} {}'.format(emp1.fname,emp1.lname))
print('{} {}'.format(emp2.fname,emp2.lname))

O/P:
Anand Kumar
Test User

But the problem with this code is, we have to write this print statement for all of our class 
instance variables. This can be avoided by creating a method within our class and using it as a 
blue print to return full names.

class Employee:
    def __init__(self,fname,lname,age):
        self.fname=fname
        self.lname=lname
        self.age=age
        self.email=fname+'.'+lname+'@company.com'
    def fullname(self):
        return '{} {}'.format(self.fname,self.lname)

emp1=Employee('Anand','Kumar',28)
emp2=Employee('Test','User',None)
print(emp1.email)
print(emp2.email)
print(emp1.fullname())
print(emp2.fullname())

O/P:
Anand.Kumar@company.com
Test.User@company.com
Anand Kumar
Test User

As mentioned before, class instance will be the first argument (self) for class methods. Hence, we
passed 'self' as the first argument in our fullname() method. We also used emp1.fullname() in the
print statement because it is a method and used emp1.email as it is an attribute.

If we don't pass the instance/self as the first argument to our class methods, then we will get 
an error.

class Employee:
    def __init__(self,fname,lname,age):
        self.fname=fname
        self.lname=lname
        self.age=age
        self.email=fname+'.'+lname+'@company.com'
    def fullname():
        return '{} {}'.format(fname,lname)
emp1=Employee('Anand','Kumar',28)
emp2=Employee('Test','User',None)
print(emp1.fullname())

O/P:
TypeError: fullname() takes 0 positional arguments but 1 was given

Though we didn't pass any arguments to the fullname() method, the class instance (self) is passed
as the first argument by default. That is the reason the error message says 1 arg was given.


We can also invoke our class methods with the class name directly, as shown below.

class Employee:
    def __init__(self,fname,lname,age):
        self.fname=fname
        self.lname=lname
        self.age=age
        self.email=fname+'.'+lname+'@company.com'
    def fullname(self):
        return '{} {}'.format(self.fname,self.lname)
emp1=Employee('Anand','Kumar',28)
emp2=Employee('Test','User',None)
print(Employee.fullname(emp1))      # Invoking class methods with Class name directly
print(emp2.fullname())              # Invoking class methods with class instance variable name

O/P:
Anand Kumar
Test User

When we invoke our class methods using class instance variables such as emp1 and emp2, in the form
of emp1.fullname() , we don't have to pass the instance/instance variable name manaually, as the
instance variable is automatically passed as 'self' by default.
However, if we are going to invoke our class methods directly by class name, such as 
Employee.fullname(emp1), then we must pass the instance variable emp1 or emp2 as the argument. 
Otherwise, it won't work.


